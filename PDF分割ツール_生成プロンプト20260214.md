# PDF分割・統合ツール 生成プロンプト v2

> **使い方**: 以下のプロンプトをそのままAI（Claude、ChatGPTなど）に貼り付けてください。
> 1つのHTMLファイルとして、完全に動作するPDF分割ツールが生成されます。

---

## プロンプト（ここから下をコピーして貼り付け）

````
以下の仕様で、1つのHTMLファイルとして完結する「ローカルPDF分割・統合ツール」を作成してください。
サーバー不要・完全ブラウザ処理で、ファイルは外部に送信されません。

【重要ルール】
- 絵文字（Unicode Emoji）は一切使用禁止。タイトル、ボタン、ラベル、ステータスメッセージすべてにおいて絵文字を含めないこと。
- アイコンが必要な場合はテキスト記号（■ ● ▶ ◆ など）で代用すること。
- ライブラリの役割分担を厳守すること:
  - pdf-lib: PDFの読み込み、ページ数取得、PDF分割・結合、メタデータ設定に使用
  - PDF.js: 画像レンダリング（PDFを画像に変換する時のみ）に使用。ファイル読み込みやページ数取得には使わない

## 使用ライブラリ（すべて cdnjs.cloudflare.com からCDN読み込み）
- pdf-lib 1.17.1（PDFの読み込み・分割・新規PDF作成・メタデータ設定）
- PDF.js 3.11.174（PDFを画像としてレンダリングする時のみ使用）※workerSrcも同バージョンで設定必須
- JSZip 3.10.1（ファイルをZIPにまとめる）
- FileSaver.js 2.0.5（ファイルのダウンロード保存）

## 画面構成（上から順に4ステップ + 実行ボタン + ステータス）

### ヘッダー
- h1タイトル: 「PDF 分割・統合ツール」（絵文字なし）
- サブタイトル: 「完全ローカル処理。サーバーには送信されません。」

### ステップ1: ファイル選択
- <input type="file" accept=".pdf">はdisplay:noneで非表示
- カスタムの<label>をボタンとして表示。テキスト: 「PDFファイルを選択」
- 読み込み後にファイル情報エリアを表示（例: 「report.pdf (全12ページ)」）
- ファイル情報は初期display:none、読み込み後に.visibleクラスでdisplay:blockに切替

### ステップ2: ページ範囲指定
- 入力補助エリア（flexbox横並び）:
  - <input type="number" placeholder="開始" min="1">
  - テキスト「〜」
  - <input type="number" placeholder="終了" min="1">
  - <button>「追加」</button>
- 追加ボタンの動作:
  1. 開始値のみ入力 → その数字を追加（例: "5"）
  2. 開始・終了とも入力 → 範囲を追加（例: "1-3"）
  3. 既に値がある場合はカンマ+スペースで追加（例: "1-3, 7-9"）
  4. 追加後、number入力2つをクリア
  5. モードプレビューを更新
- 手動入力欄: <input type="text" placeholder="例: 1-3, 5, 7-9">
- inputイベントで全角→半角の自動変換を常時実行:
  - 全角数字（０-９）→ 半角数字: s.charCodeAt(0) - 0xFEE0 で変換
  - 全角ハイフン（ー、－、—）→ 半角ハイフン(-)
  - 全角カンマ（，）、読点（、）→ 半角カンマ(,)
- 入力変更のたびにモードプレビューも更新

### ステップ3: 出力モード選択（ラジオボタン・name="outputMode"）
3つの選択肢をカード形式（labelタグ）で縦に並べる:

1. 「まとめて1ファイルに結合」 (value="merge") ※checked属性でデフォルト選択
   - 説明: 「すべてのページを1つのファイルにまとめます」

2. 「グループごとに別ファイルで出力（ZIP）」 (value="split")
   - 説明: 「カンマ区切りの各グループを独立したファイルとして出力（ZIPでまとめてダウンロード）」

3. 「グループごとに別ファイルで出力（ZIPなし）」 (value="split-nozip")
   - 説明: 「各ファイルを0.8秒間隔で個別ダウンロード（セキュリティソフトでZIPがブロックされる場合）」

モードプレビュー: ラジオボタンの下に動的プレビューエリア（div）を配置
- ページ範囲が未入力の時は非表示（.visibleクラスで切替）
- 背景: #fff9e6、border-left: 4px solid #ffa726、border-radius: 4px
- 選択モードとページ範囲入力値に応じた具体例をinnerHTMLで表示:
  - merge時: "例: 「1-3, 7-9」 → すべてのページを含む1つのファイルが生成されます"
  - split時: "例: 「1-3, 7-9」 → 「1-3のファイル」「7-9のファイル」が生成され、ZIPでダウンロード"
  - split-nozip時: "例: 「1-3, 7-9」 → 「1-3のファイル」「7-9のファイル」が0.8秒間隔で個別ダウンロード"

### ステップ4: 出力形式選択（ラジオボタン・name="outputFormat"）
1. 「PDFファイル (.pdf)」 (value="pdf") ※checked属性でデフォルト選択
   - 説明: 「選択ページだけの新しいPDFを生成」
2. 「画像: まとめてZIPで保存」 (value="image-zip")
   - 説明: 「各ページをJPEG画像にしてZIPでダウンロード」
3. 「画像: 1枚ずつ保存」 (value="image-single")
   - 説明: 「0.8秒間隔で1枚ずつダウンロード（ZIPがブロックされる場合の代替）」

### 実行ボタン
- テキスト: 「ファイルの分割・ダウンロード」（絵文字なし）
- width: 100%のフルワイド表示
- border-radius: 12px（丸ボタンではなく角丸の長方形）
- ファイル未読み込み時は disabled（グレーアウト、cursor: not-allowed、opacity: 0.6）
- ホバーで translateY(-2px) + box-shadow増加
- active時に transform: scale(0.98)

### ステータス表示エリア
- div要素、初期display:none、処理中に.visibleクラスでdisplay:blockに切替
- 4種類の状態をCSSクラスで切替（クラス名と色は以下の通り）:
  - success: background: #e8f5e9; border: 2px solid #4caf50; color: #2e7d32;
  - error: background: #ffebee; border: 2px solid #f44336; color: #c62828;
  - processing: background: #e3f2fd; border: 2px solid #2196f3; color: #1565c0;
  - warning: background: #fff3e0; border: 2px solid #ff9800; color: #e65100;
- @keyframes fadeIn: opacity 0→1、translateY(-10px)→0、duration 0.3s
- innerHTMLで表示し、<br>や<small>タグでの改行・補足が使えるようにする

## UIデザインの詳細

### ステップ番号バッジ
- 各ステップのタイトル先頭に丸い番号バッジを付ける
- CSS:
  width: 28px; height: 28px;
  background: linear-gradient(135deg, #1a237e, #4a148c);
  color: white; border-radius: 50%;
  display: inline-flex; align-items: center; justify-content: center;
  font-size: 14px; font-weight: 700;
  margin-right: 10px;

### ラジオボタンのカード型UI（JavaScriptの実装方法を含む）
HTML構造（各選択肢ごとに）:
  <label class="radio-card selected">
    <input type="radio" name="outputMode" value="merge" checked>
    <span class="radio-title">まとめて1ファイルに結合</span>
    <span class="radio-desc">すべてのページを1つのファイルにまとめます</span>
  </label>

CSS:
  .radio-card: padding: 16px; background: white; border: 2px solid #e0e0e0; border-radius: 10px; cursor: pointer;
  .radio-card:hover: border-color: #4a148c;
  .radio-card.selected: border-color: #4a148c; background: #f3e5f5;
  .radio-card input[type="radio"]: margin-right: 10px;（表示する。opacity:0で非表示にしない）
  .radio-title: font-weight: 600; font-size: 15px; color: #333;
  .radio-desc: font-size: 13px; color: #666; margin-top: 5px; margin-left: 24px;

JavaScript（ページ読み込み時に設定）:
  document.querySelectorAll('.radio-card').forEach(card => {
    card.addEventListener('click', function() {
      const radio = this.querySelector('input[type="radio"]');
      radio.checked = true;
      // 同じname属性の全カードから.selectedを除去
      const groupName = radio.name;
      document.querySelectorAll('input[name="' + groupName + '"]').forEach(r => {
        r.closest('.radio-card').classList.remove('selected');
      });
      // クリックされたカードに.selectedを付与
      this.classList.add('selected');
      // outputModeの場合はモードプレビューも更新
      if (groupName === 'outputMode') {
        updateModePreview();
      }
    });
  });

## 技術的な処理の流れ

### グローバル変数
- pdfData: ArrayBuffer（読み込んだPDFのバイトデータ）
- totalPages: 総ページ数（数値）
- fileName: 拡張子(.pdf)を除いたファイル名（文字列）

### ファイル読み込み処理（必ずpdf-libを使用）
1. file.arrayBuffer()でArrayBufferとして読み込み
2. pdf-libで読み込み: const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
3. ページ数取得: totalPages = pdfDoc.getPageCount();
   ※ PDF.jsのnumPagesは使わない。pdf-libのgetPageCount()を使うこと
4. pdfDataにarrayBufferを保存
5. fileNameにfile.name.replace('.pdf', '')を保存
6. ファイル情報を画面に表示
7. number入力のmax属性にtotalPagesを設定
8. 実行ボタンのdisabledをfalseに
9. エラー時: console.error(error)で出力 + ステータスに「PDFの読み込みに失敗しました。暗号化されたPDFの可能性があります。」を表示

### ページ範囲パース関数（2種類必要）

parsePageGroups(input, maxPages) -- 分割モード用:
- input.split(',')でカンマ区切り分割 → trim() → 空文字除去
- 各グループについて:
  - '-'を含む場合: split('-')で開始・終了を取得、Math.max(1,...)とMath.min(maxPages,...)でクランプ、ループで-1してSetに追加
  - '-'を含まない場合: parseInt()で数値化、範囲チェック後-1してSetに追加
- 各グループをSet→Array→sort後、配列の配列として返す
- 例: "1-3, 7-9" → [[0,1,2], [6,7,8]]

parsePageRangeFlat(input, maxPages) -- 結合モード用:
- 全グループをまとめて1つのSetに入れ、ソートして1つの配列で返す

### PDF出力: 結合モード (generateMergedPDF)
1. const sourcePdf = await PDFLib.PDFDocument.load(pdfData);
2. const newPdf = await PDFLib.PDFDocument.create();
3. メタデータ設定:
   newPdf.setTitle(fileName + '_split');
   newPdf.setProducer('PDF Split Tool');
   newPdf.setCreator('Local PDF Tool');
   newPdf.setCreationDate(new Date());
   newPdf.setModificationDate(new Date());
4. const copiedPages = await newPdf.copyPages(sourcePdf, pages);
5. copiedPages.forEach(page => newPdf.addPage(page));
6. const pdfBytes = await newPdf.save();
7. const blob = new Blob([pdfBytes], { type: 'application/pdf' });
8. saveAs(blob, fileName + '_split.pdf');

### PDF出力: 分割モード・ZIP (generateSplitPDFs)
1. JSZipインスタンスを作成
2. const sourcePdf = await PDFLib.PDFDocument.load(pdfData);
3. 各グループをループ:
   - PDFDocument.create() + メタデータ設定
   - copyPages → addPage → save()でバイト配列取得
   - ファイル名の決定:
     - 単一ページ: fileName + '_p5.pdf'
     - 範囲: fileName + '_p1-3.pdf'（先頭ページ+1 と 末尾ページ+1 で生成）
   - zip.file(filename, pdfBytes)でZIPに追加
4. const zipBlob = await zip.generateAsync({type: 'blob'});
5. saveAs(zipBlob, fileName + '_split.zip');

### PDF出力: 分割モード・ZIPなし (generateSplitPDFsNoZip)
1. const sourcePdf = await PDFLib.PDFDocument.load(pdfData);
2. 各グループをforループ:
   - 進捗をステータスに表示: 「PDFファイル生成中... (2/3)」
   - PDFDocument.create() + メタデータ設定
   - copyPages → addPage → save() → Blob → saveAs()で個別ダウンロード
   - ファイル名はZIP版と同じルール
3. ファイル間のdelay: if (i < pageGroups.length - 1) { await new Promise(resolve => setTimeout(resolve, 800)); }

### 画像レンダリング共通関数 (renderPageToImage)
※ここでのみPDF.jsを使用する
1. const loadingTask = pdfjsLib.getDocument({data: pdfData});
2. const pdf = await loadingTask.promise;
3. const page = await pdf.getPage(pageNum + 1);  // PDF.jsは1始まり
4. const viewport = page.getViewport({scale: 2.0});
5. const canvas = document.createElement('canvas');
6. const context = canvas.getContext('2d');
7. canvas.width = viewport.width; canvas.height = viewport.height;
8. await page.render({canvasContext: context, viewport: viewport}).promise;
9. return new Promise(resolve => { canvas.toBlob(resolve, 'image/jpeg', 0.9); });

### 画像ZIP出力 (generateImagesZIP)
- 引数: pages（フラット配列）, mode（'merge' or それ以外）
- 結合モード(mode==='merge'): zip.folder('images')にpage_001.jpg形式で格納
- 分割モード(mode!=='merge'):
  1. parsePageGroups()を呼び出してグループ分け
  2. 各グループごとにzip.folder('p1-3')のようにサブフォルダ作成
     - フォルダ名: 'p' + (先頭ページ+1) + '-' + (末尾ページ+1)
  3. 各サブフォルダ内にpage_001.jpgのように画像を配置
  4. 進捗をステータスに表示
- ZIPファイル名: fileName + '_images.zip'

### 画像1枚ずつ出力 (generateImagesSingle)
- parsePageRangeFlat()で全ページをフラット配列化
- 各画像をsaveAsで個別ダウンロード
- ファイル名: fileName + '_page_001.jpg'（ページ番号はゼロ埋め3桁）
- 0.8秒間隔（最後のファイル後はdelayなし）

### メイン実行処理 (executeBtnのclickイベント)
- バリデーション:
  1. pdfDataがnullならエラー「PDFファイルを選択してください」で return
  2. ページ範囲が空文字ならエラー「ページ範囲を指定してください」で return
- executeBtn.disabled = true;
- outputModeとoutputFormatの値をquerySelectorで取得
- try-catch-finallyで分岐:
  try:
    if (outputFormat === 'pdf') {
      if (outputMode === 'merge') generateMergedPDF(pages)
      else if (outputMode === 'split') generateSplitPDFs(pageGroups)
      else if (outputMode === 'split-nozip') generateSplitPDFsNoZip(pageGroups)
    } else if (outputFormat === 'image-zip') {
      generateImagesZIP(pages, outputMode)
    } else if (outputFormat === 'image-single') {
      generateImagesSingle(pages)
    }
    成功メッセージ + Windowsブロック解除手順
  catch (error):
    console.error('処理エラー:', error);
    ステータスにエラー表示
  finally:
    executeBtn.disabled = false;

### showStatus関数
function showStatus(message, type) {
  statusArea.innerHTML = message;
  statusArea.className = 'status-area visible ' + type;
}
※引数の順序: 第1引数=メッセージ(文字列/HTML)、第2引数=種類('success','error','processing','warning')

## デザイン要件
- CSS変数は不使用（直接カラーコード指定）
- 背景: linear-gradient(135deg, #1a237e 0%, #4a148c 40%, #c2185b 100%)
- body: padding: 40px 20px; line-height: 1.6;
- コンテナ: background: white; max-width: 800px; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); padding: 40px;
- 入力グループ: background: #f8f9fa; border-radius: 12px; border: 2px solid #e0e0e0; padding: 20px;
- ファイル選択ボタン: background: linear-gradient(135deg, #1a237e, #4a148c); color: white; border-radius: 8px; padding: 15px 25px;
- 追加ボタン: background: #4a148c; color: white;
- 実行ボタン: background: linear-gradient(135deg, #1a237e, #c2185b); width: 100%; padding: 18px; border-radius: 12px; font-size: 18px; font-weight: 700;
- inputフォーカス時: outline: none; border-color: #4a148c;
- モバイル対応: @media (max-width: 600px) { コンテナpadding縮小、入力補助をflex-direction:columnに変更 }
- CSSリセット: * { margin: 0; padding: 0; box-sizing: border-box; }
- フォント: 'Helvetica Neue', 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', sans-serif

## 注意事項
- 絵文字（Unicode Emoji）は一切使用禁止。UIテキスト、ステータスメッセージ、コメントすべてにおいて絵文字を含めないこと。
- PDF.jsのworkerSrcを必ず設定（CDNのpdf.worker.min.js、本体と同じバージョン3.11.174）
- ファイル読み込みにはpdf-libを使用する（PDF.jsのnumPagesは使わない）
- 全角入力の自動変換はinputイベントで常時実行
- 生成PDFにはメタデータ（Title, Producer, Creator, CreationDate, ModificationDate）を必ず設定
- ステータスの完了メッセージに以下を含める: 「ダウンロードがブロックされた場合: ファイルを右クリック → プロパティ → ブロックの解除にチェック → OK」
- エラー発生時はconsole.errorでログ出力し、ステータスにもエラーメッセージを表示
- 印刷用CSSは不要

すべてを1つのHTMLファイルにまとめて、コピペでそのまま動く状態で出力してください。
````

---

## 補足

- **カスタマイズのヒント**: プロンプト末尾に「タイトルを○○に変更」「カラーを○○系に変更」などを追記すれば、デザインを自由に変えられます。
- **画像解像度の変更**: プロンプト内の `scale: 2.0` の値を上げると高画質（ファイルサイズ増）、下げると軽量になります。
- **対応ブラウザ**: Chrome, Edge, Firefox の最新版で動作します（IE非対応）。
- **絵文字を使いたい場合**: プロンプト冒頭の「絵文字は一切使用禁止」の指示を削除し、各項目に好みの絵文字を追記してください。
