# PDF分割・統合ツール 生成プロンプト v3

> **使い方**: 以下のプロンプトをそのままAI（Claude、ChatGPTなど）に貼り付けてください。
> 1つのHTMLファイルとして、完全に動作するPDF分割ツールが生成されます。

---

## プロンプト（ここから下をコピーして貼り付け）

````
以下の仕様で、1つのHTMLファイルとして完結する「ローカルPDF分割・統合ツール」を作成してください。
サーバー不要・完全ブラウザ処理で、ファイルは外部に送信されません。

【重要ルール】
- 絵文字（Unicode Emoji）は一切使用禁止。タイトル、ボタン、ラベル、ステータスメッセージすべてにおいて絵文字を含めないこと。アイコンが必要な場合はテキスト記号（■ ● ▶ ◆ など）で代用すること。
- ライブラリの役割分担:
  - pdf-lib: PDFの読み込み(PDFDocument.load)、ページ数取得(getPageCount)、PDF分割・結合、メタデータ設定に使用
  - PDF.js: 画像レンダリング専用（PDFを画像に変換する時のみ使用）。ファイル読み込みやページ数取得には使わない
- PDF.js 3.x の ArrayBuffer 制約:
  pdfjsLib.getDocument({data: ...}) は渡されたArrayBufferを内部で transfer（所有権移転）する。
  そのため同じArrayBufferを2回以上 getDocument に渡すと 'detached ArrayBuffer' エラーになる。
  必ず new Uint8Array(pdfData) でコピーを渡すか、getDocumentは1回だけ呼んでPDFドキュメントを使い回すこと。

## 使用ライブラリ（すべて cdnjs.cloudflare.com からCDN読み込み）
- pdf-lib 1.17.1
- PDF.js 3.11.174 ※workerSrcも同バージョンで設定必須
- JSZip 3.10.1
- FileSaver.js 2.0.5

## 画面構成（上から順に4ステップ + 実行ボタン + ステータス）

### ヘッダー
- h1タイトル: 「PDF 分割・統合ツール」（絵文字なし）
- サブタイトル: 「完全ローカル処理。サーバーには送信されません。」

### ステップ1: ファイル選択
- <input type="file" accept=".pdf">はdisplay:noneで非表示
- カスタムの<label>をボタンとして表示。テキスト: 「PDFファイルを選択」
- 読み込み後にファイル情報エリアを表示（例: 「report.pdf (全12ページ)」）
- ファイル情報は初期display:none、読み込み後に.visibleクラスでdisplay:blockに切替

### ステップ2: ページ範囲指定
- 入力補助エリア（flexbox横並び）:
  - <input type="number" placeholder="開始" min="1">
  - テキスト「〜」
  - <input type="number" placeholder="終了" min="1">
  - <button>「追加」</button>
- 追加ボタンの動作:
  1. 開始値のみ入力 → その数字を追加（例: "5"）
  2. 開始・終了とも入力 → 範囲を追加（例: "1-3"）
  3. 既に値がある場合はカンマ+スペースで追加（例: "1-3, 7-9"）
  4. 追加後、number入力2つをクリア
  5. モードプレビューを更新
- 手動入力欄: <input type="text" placeholder="例: 1-3, 5, 7-9">
- inputイベントで全角→半角の自動変換を常時実行:
  - 全角数字（０-９）→ 半角数字: s.charCodeAt(0) - 0xFEE0 で変換
  - 全角ハイフン（ー、－、—）→ 半角ハイフン(-)
  - 全角カンマ（，）、読点（、）→ 半角カンマ(,)
- 入力変更のたびにモードプレビューも更新

### ステップ3: 出力モード選択（ラジオボタン・name="outputMode"）
3つの選択肢をカード形式（labelタグ）で縦に並べる:

1. 「まとめて1ファイルに結合」 (value="merge") ※checked属性でデフォルト選択
   - 説明: 「すべてのページを1つのファイルにまとめます」

2. 「グループごとに別ファイルで出力（ZIP）」 (value="split")
   - 説明: 「カンマ区切りの各グループを独立したファイルとして出力（ZIPでまとめてダウンロード）」

3. 「グループごとに別ファイルで出力（ZIPなし）」 (value="split-nozip")
   - 説明: 「各ファイルを0.8秒間隔で個別ダウンロード（セキュリティソフトでZIPがブロックされる場合）」

モードプレビュー: ラジオボタンの下に動的プレビューエリア（div）を配置
- ページ範囲が未入力の時は非表示（.visibleクラスで切替）
- 背景: #fff9e6、border-left: 4px solid #ffa726、border-radius: 4px
- 選択モードとページ範囲入力値に応じた具体例をinnerHTMLで表示

### ステップ4: 出力形式選択（ラジオボタン・name="outputFormat"）
1. 「PDFファイル (.pdf)」 (value="pdf") ※checked属性でデフォルト選択
2. 「画像: まとめてZIPで保存」 (value="image-zip")
3. 「画像: 1枚ずつ保存」 (value="image-single")

### 実行ボタン
- テキスト: 「ファイルの分割・ダウンロード」（絵文字なし）
- width: 100%のフルワイド、border-radius: 12px
- ファイル未読み込み時は disabled

### ステータス表示エリア
- 初期display:none、.visibleクラスでdisplay:blockに切替
- 4種類: success(緑), error(赤), processing(青), warning(オレンジ)
  - success: background: #e8f5e9; border: 2px solid #4caf50; color: #2e7d32;
  - error: background: #ffebee; border: 2px solid #f44336; color: #c62828;
  - processing: background: #e3f2fd; border: 2px solid #2196f3; color: #1565c0;
  - warning: background: #fff3e0; border: 2px solid #ff9800; color: #e65100;
- fadeInアニメーション付き（0.3s）
- innerHTMLで表示

## UIデザインの詳細

### ステップ番号バッジ
CSS:
  width: 28px; height: 28px;
  background: linear-gradient(135deg, #1a237e, #4a148c);
  color: white; border-radius: 50%;
  display: inline-flex; align-items: center; justify-content: center;
  font-size: 14px; font-weight: 700; margin-right: 10px;

### ラジオボタンのカード型UI
HTML構造:
  <label class="radio-card selected">
    <input type="radio" name="outputMode" value="merge" checked>
    <span class="radio-title">まとめて1ファイルに結合</span>
    <span class="radio-desc">すべてのページを1つのファイルにまとめます</span>
  </label>

CSS:
  .radio-card: padding: 16px; background: white; border: 2px solid #e0e0e0; border-radius: 10px; cursor: pointer;
  .radio-card:hover: border-color: #4a148c;
  .radio-card.selected: border-color: #4a148c; background: #f3e5f5;
  .radio-card input[type="radio"]: margin-right: 10px;（表示したまま。opacity:0にしない）
  .radio-title: font-weight: 600; font-size: 15px;
  .radio-desc: font-size: 13px; color: #666; margin-top: 5px; margin-left: 24px;

JavaScript:
  document.querySelectorAll('.radio-card').forEach(card => {
    card.addEventListener('click', function() {
      const radio = this.querySelector('input[type="radio"]');
      radio.checked = true;
      const groupName = radio.name;
      document.querySelectorAll('input[name="' + groupName + '"]').forEach(r => {
        r.closest('.radio-card').classList.remove('selected');
      });
      this.classList.add('selected');
      if (groupName === 'outputMode') { updateModePreview(); }
    });
  });

## 技術的な処理の流れ

### グローバル変数
- pdfData: ArrayBuffer（読み込んだPDFのバイトデータ）
- totalPages: 総ページ数
- fileName: 拡張子(.pdf)を除いたファイル名

### ファイル読み込み処理（pdf-libを使用）
1. const arrayBuffer = await file.arrayBuffer();
2. const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
3. totalPages = pdfDoc.getPageCount();
4. pdfData = arrayBuffer;
5. fileName = file.name.replace('.pdf', '');
6. UIを更新（ファイル情報表示、max属性設定、ボタン有効化）
7. エラー時: console.error + ステータスに「暗号化されたPDFの可能性」表示

### ページ範囲パース関数（2種類）

parsePageGroups(input, maxPages) -- 分割モード用:
- カンマ区切りで分割 → 各グループをSet → sort → 配列の配列で返す
- 例: "1-3, 7-9" → [[0,1,2], [6,7,8]]（0始まり）

parsePageRangeFlat(input, maxPages) -- 結合モード用:
- 全グループを1つのSetにまとめ、sortして配列で返す

### PDF出力: 結合モード (generateMergedPDF)
1. const sourcePdf = await PDFLib.PDFDocument.load(pdfData);
2. const newPdf = await PDFLib.PDFDocument.create();
3. メタデータ設定: setTitle, setProducer('PDF Split Tool'), setCreator('Local PDF Tool'), setCreationDate(new Date()), setModificationDate(new Date())
4. copyPages → addPage → save() → Blob → saveAs(blob, fileName + '_split.pdf')

### PDF出力: 分割モード・ZIP (generateSplitPDFs)
1. JSZipインスタンス作成 + PDFLib.PDFDocument.load(pdfData)
2. 各グループ: create + メタデータ + copyPages + save → zip.file()
3. ファイル名: 単一ページ '_p5.pdf'、範囲 '_p1-3.pdf'
4. saveAs(zipBlob, fileName + '_split.zip')

### PDF出力: 分割モード・ZIPなし (generateSplitPDFsNoZip)
1. PDFLib.PDFDocument.load(pdfData)
2. 各グループ: create + メタデータ + copyPages + save → Blob → saveAs
3. 進捗表示 + 0.8秒delay（最後のファイル後はなし）

### 画像レンダリング（重要: ArrayBuffer の detach 対策）

【設計方針】
PDF.js 3.x では getDocument に ArrayBuffer を渡すと内部で transfer される。
そのため renderPageToImage のような関数で毎回 getDocument を呼ぶ設計にすると、
2ページ目以降で 'Cannot transfer a detached ArrayBuffer' エラーが発生する。

以下のどちらかの方法で実装すること:

方法A（推奨）: 呼び出し元でPDFを1回ロードし、pageオブジェクトを渡す
  // 呼び出し元（generateImagesZIPなど）
  const pdfJsDoc = await pdfjsLib.getDocument({data: new Uint8Array(pdfData)}).promise;
  for (...) {
    const blob = await renderPageToBlob(pdfJsDoc, pageIndex);
  }

  // レンダリング関数
  async function renderPageToBlob(pdfJsDoc, pageNum) {
    const page = await pdfJsDoc.getPage(pageNum + 1);
    const viewport = page.getViewport({scale: 2.0});
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    await page.render({canvasContext: context, viewport: viewport}).promise;
    return new Promise(resolve => { canvas.toBlob(resolve, 'image/jpeg', 0.9); });
  }

方法B: 毎回コピーを渡す（非推奨だが動作する）
  async function renderPageToImage(pageNum) {
    const pdf = await pdfjsLib.getDocument({data: new Uint8Array(pdfData)}).promise;
    // ... 以下同じ
  }

### 画像ZIP出力 (generateImagesZIP)
- まずPDF.jsでPDFを1回だけロード:
  const pdfJsDoc = await pdfjsLib.getDocument({data: new Uint8Array(pdfData)}).promise;
- mode==='merge': zip.folder('images')にpage_001.jpg形式で格納
- mode!=='merge': グループごとにサブフォルダ(p1-3/)を作成
- 各ページ: renderPageToBlob(pdfJsDoc, pageIndex) で画像生成
- ZIPファイル名: fileName + '_images.zip'

### 画像1枚ずつ出力 (generateImagesSingle)
- まずPDF.jsでPDFを1回だけロード:
  const pdfJsDoc = await pdfjsLib.getDocument({data: new Uint8Array(pdfData)}).promise;
- 各画像をrenderPageToBlob → saveAsで個別ダウンロード
- ファイル名: fileName + '_page_001.jpg'（ゼロ埋め3桁）
- 0.8秒間隔（最後はdelayなし）

### showStatus関数
function showStatus(message, type) {
  statusArea.innerHTML = message;
  statusArea.className = 'status-area visible ' + type;
}
※引数順: 第1引数=メッセージ(HTML可)、第2引数=種類('success','error','processing','warning')

### メイン実行処理
- バリデーション → executeBtn.disabled = true
- outputMode + outputFormat の組み合わせで分岐
- try-catch-finally（finallyでボタン再有効化）
- 完了メッセージにWindowsブロック解除手順を含める

## デザイン要件
- CSS変数不使用（直接カラーコード）
- 背景: linear-gradient(135deg, #1a237e 0%, #4a148c 40%, #c2185b 100%)
- body: padding: 40px 20px; line-height: 1.6;
- コンテナ: white, max-width: 800px, border-radius: 20px, box-shadow: 0 20px 60px rgba(0,0,0,0.3), padding: 40px
- 入力グループ: #f8f9fa, border-radius: 12px, border: 2px solid #e0e0e0, padding: 20px
- ファイル選択ボタン: gradient(#1a237e→#4a148c), white, border-radius: 8px, padding: 15px 25px
- 実行ボタン: gradient(#1a237e→#c2185b), width: 100%, padding: 18px, border-radius: 12px, font-size: 18px, font-weight: 700
- disabled時: background: #ccc, cursor: not-allowed, opacity: 0.6
- ホバー: translateY(-2px) + box-shadow, active: scale(0.98)
- モバイル: @media (max-width: 600px) { padding縮小, flex-direction: column }
- リセット: * { margin: 0; padding: 0; box-sizing: border-box; }
- フォント: 'Helvetica Neue', 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', sans-serif

## 注意事項
- 絵文字は一切使用禁止
- PDF.jsのworkerSrcを必ず設定（バージョン3.11.174）
- ファイル読み込みにはpdf-libを使用（PDF.jsのnumPagesは使わない）
- getDocumentには必ず new Uint8Array(pdfData) を渡す（ArrayBufferを直接渡さない）
- getDocumentは画像処理関数の外で1回だけ呼び、PDFドキュメントオブジェクトを使い回す
- メタデータ（Title, Producer, Creator, CreationDate, ModificationDate）を必ず設定
- ステータス完了メッセージに「ブロック解除手順」を含める
- エラーはconsole.errorで出力 + ステータスに表示

すべてを1つのHTMLファイルにまとめて、コピペでそのまま動く状態で出力してください。
````

---

## 補足

- **カスタマイズのヒント**: プロンプト末尾に「タイトルを○○に変更」「カラーを○○系に変更」などを追記すれば、デザインを変えられます。
- **画像解像度の変更**: `scale: 2.0` の値を上げると高画質（ファイルサイズ増）、下げると軽量になります。
- **対応ブラウザ**: Chrome, Edge, Firefox の最新版で動作します（IE非対応）。
- **絵文字を使いたい場合**: 冒頭の「絵文字は一切使用禁止」を削除し、各項目に好みの絵文字を追記してください。
