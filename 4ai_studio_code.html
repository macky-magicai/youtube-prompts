<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF 分割・統合ツール</title>
    
    <!-- ライブラリ読み込み (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        /* CSSリセット */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Helvetica Neue', 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', sans-serif;
            background: linear-gradient(135deg, #1a237e 0%, #4a148c 40%, #c2185b 100%);
            min-height: 100vh;
            padding: 40px 20px;
            color: #333;
            line-height: 1.6;
        }

        /* メインコンテナ */
        .container {
            background: white;
            max-width: 800px;
            margin: 0 auto;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }

        /* ヘッダー */
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        h1 {
            font-size: 28px;
            color: #1a237e;
            margin-bottom: 10px;
        }
        .subtitle {
            font-size: 14px;
            color: #666;
        }

        /* ステップ共通 */
        .step-section {
            margin-bottom: 30px;
        }
        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .step-badge {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #1a237e, #4a148c);
            color: white;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .step-title {
            font-size: 18px;
            font-weight: 700;
            color: #333;
        }

        /* 入力エリア共通スタイル */
        .input-group {
            background: #f8f9fa;
            border-radius: 12px;
            border: 2px solid #e0e0e0;
            padding: 20px;
        }

        /* ファイル選択 */
        .file-upload-wrapper {
            text-align: center;
        }
        .file-label {
            display: inline-block;
            background: linear-gradient(135deg, #1a237e, #4a148c);
            color: white;
            border-radius: 8px;
            padding: 15px 25px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .file-label:hover {
            opacity: 0.9;
        }
        .file-info {
            margin-top: 15px;
            font-weight: 600;
            color: #1a237e;
            display: none;
        }
        .file-info.visible {
            display: block;
        }

        /* ページ範囲指定 */
        .range-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        input[type="number"], input[type="text"] {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
        }
        input[type="number"] {
            width: 80px;
        }
        input[type="text"] {
            width: 100%;
        }
        input:focus {
            outline: none;
            border-color: #4a148c;
        }
        .add-btn {
            background: #4a148c;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: 600;
        }
        .add-btn:hover {
            background: #311b92;
        }

        /* ラジオボタンカード */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .radio-card {
            padding: 16px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            display: block;
            position: relative;
            transition: all 0.2s;
        }
        .radio-card:hover {
            border-color: #4a148c;
        }
        .radio-card.selected {
            border-color: #4a148c;
            background: #f3e5f5;
        }
        .radio-card input[type="radio"] {
            margin-right: 10px;
            accent-color: #4a148c;
        }
        .radio-title {
            font-weight: 600;
            font-size: 15px;
            color: #333;
        }
        .radio-desc {
            display: block;
            font-size: 13px;
            color: #666;
            margin-top: 5px;
            margin-left: 24px;
        }

        /* モードプレビュー */
        #modePreview {
            margin-top: 15px;
            padding: 12px;
            background: #fff9e6;
            border-left: 4px solid #ffa726;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
            display: none;
        }
        #modePreview.visible {
            display: block;
        }

        /* 実行ボタン */
        #executeBtn {
            background: linear-gradient(135deg, #1a237e, #c2185b);
            color: white;
            width: 100%;
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s, opacity 0.2s;
            margin-top: 10px;
        }
        #executeBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(26, 35, 126, 0.3);
        }
        #executeBtn:active:not(:disabled) {
            transform: scale(0.98);
        }
        #executeBtn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }

        /* ステータスエリア */
        .status-area {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
            font-size: 14px;
            animation: fadeIn 0.3s ease-out;
        }
        .status-area.visible {
            display: block;
        }
        .status-area.success {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            color: #2e7d32;
        }
        .status-area.error {
            background: #ffebee;
            border: 2px solid #f44336;
            color: #c62828;
        }
        .status-area.processing {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            color: #1565c0;
        }
        .status-area.warning {
            background: #fff3e0;
            border: 2px solid #ff9800;
            color: #e65100;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* モバイル対応 */
        @media (max-width: 600px) {
            .container { padding: 20px; }
            .range-inputs { flex-direction: column; align-items: stretch; }
            input[type="number"] { width: 100%; }
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>PDF 分割・統合ツール</h1>
        <div class="subtitle">完全ローカル処理。サーバーには送信されません。</div>
    </header>

    <!-- ステップ1: ファイル選択 -->
    <div class="step-section">
        <div class="step-header">
            <span class="step-badge">1</span>
            <span class="step-title">ファイル選択</span>
        </div>
        <div class="input-group file-upload-wrapper">
            <input type="file" id="pdfInput" accept=".pdf" style="display: none;">
            <label for="pdfInput" class="file-label">PDFファイルを選択</label>
            <div id="fileInfo" class="file-info"></div>
        </div>
    </div>

    <!-- ステップ2: ページ範囲指定 -->
    <div class="step-section">
        <div class="step-header">
            <span class="step-badge">2</span>
            <span class="step-title">ページ範囲指定</span>
        </div>
        <div class="input-group">
            <div class="range-inputs">
                <input type="number" id="rangeStart" placeholder="開始" min="1">
                <span style="text-align:center;">〜</span>
                <input type="number" id="rangeEnd" placeholder="終了" min="1">
                <button type="button" id="addRangeBtn" class="add-btn">追加</button>
            </div>
            <input type="text" id="manualRangeInput" placeholder="例: 1-3, 5, 7-9">
        </div>
    </div>

    <!-- ステップ3: 出力モード選択 -->
    <div class="step-section">
        <div class="step-header">
            <span class="step-badge">3</span>
            <span class="step-title">出力モード選択</span>
        </div>
        <div class="radio-group">
            <label class="radio-card selected">
                <input type="radio" name="outputMode" value="merge" checked>
                <span class="radio-title">まとめて1ファイルに結合</span>
                <span class="radio-desc">すべてのページを1つのファイルにまとめます</span>
            </label>
            <label class="radio-card">
                <input type="radio" name="outputMode" value="split">
                <span class="radio-title">グループごとに別ファイルで出力（ZIP）</span>
                <span class="radio-desc">カンマ区切りの各グループを独立したファイルとして出力（ZIPでまとめてダウンロード）</span>
            </label>
            <label class="radio-card">
                <input type="radio" name="outputMode" value="split-nozip">
                <span class="radio-title">グループごとに別ファイルで出力（ZIPなし）</span>
                <span class="radio-desc">各ファイルを0.8秒間隔で個別ダウンロード（セキュリティソフトでZIPがブロックされる場合）</span>
            </label>
        </div>
        <div id="modePreview"></div>
    </div>

    <!-- ステップ4: 出力形式選択 -->
    <div class="step-section">
        <div class="step-header">
            <span class="step-badge">4</span>
            <span class="step-title">出力形式選択</span>
        </div>
        <div class="radio-group">
            <label class="radio-card selected">
                <input type="radio" name="outputFormat" value="pdf" checked>
                <span class="radio-title">PDFファイル (.pdf)</span>
                <span class="radio-desc">選択ページだけの新しいPDFを生成</span>
            </label>
            <label class="radio-card">
                <input type="radio" name="outputFormat" value="image-zip">
                <span class="radio-title">画像: まとめてZIPで保存</span>
                <span class="radio-desc">各ページをJPEG画像にしてZIPでダウンロード</span>
            </label>
            <label class="radio-card">
                <input type="radio" name="outputFormat" value="image-single">
                <span class="radio-title">画像: 1枚ずつ保存</span>
                <span class="radio-desc">0.8秒間隔で1枚ずつダウンロード（ZIPがブロックされる場合の代替）</span>
            </label>
        </div>
    </div>

    <!-- 実行ボタン -->
    <button id="executeBtn" disabled>ファイルの分割・ダウンロード</button>

    <!-- ステータス表示エリア -->
    <div id="statusArea" class="status-area"></div>
</div>

<script>
    // --- グローバル変数 ---
    let pdfData = null; // ArrayBuffer
    let totalPages = 0;
    let fileName = '';
    
    // PDF.jsのWorker設定
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // --- DOM要素 ---
    const pdfInput = document.getElementById('pdfInput');
    const fileInfo = document.getElementById('fileInfo');
    const rangeStart = document.getElementById('rangeStart');
    const rangeEnd = document.getElementById('rangeEnd');
    const addRangeBtn = document.getElementById('addRangeBtn');
    const manualRangeInput = document.getElementById('manualRangeInput');
    const modePreview = document.getElementById('modePreview');
    const executeBtn = document.getElementById('executeBtn');
    const statusArea = document.getElementById('statusArea');

    // --- ユーティリティ関数 ---
    
    // 全角→半角変換
    function toHalfWidth(str) {
        return str
            .replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
            .replace(/[ー－—]/g, '-')
            .replace(/[，、]/g, ',');
    }

    // ステータス表示
    function showStatus(message, type) {
        statusArea.innerHTML = message;
        statusArea.className = 'status-area visible ' + type;
    }

    // ページ範囲パース (分割用: 配列の配列)
    // 戻り値例: [[0,1,2], [6,7,8]] (0-indexed)
    function parsePageGroups(input, maxPages) {
        if (!input.trim()) return [];
        const groups = [];
        const parts = input.split(',').map(s => s.trim()).filter(s => s !== '');
        
        parts.forEach(part => {
            const pageSet = new Set();
            if (part.includes('-')) {
                const [startStr, endStr] = part.split('-');
                let start = parseInt(startStr);
                let end = parseInt(endStr);
                
                if (!isNaN(start) && !isNaN(end)) {
                    // 大小入れ替え対応
                    const s = Math.min(start, end);
                    const e = Math.max(start, end);
                    // 範囲クランプ
                    const actualStart = Math.max(1, s);
                    const actualEnd = Math.min(maxPages, e);
                    
                    for (let i = actualStart; i <= actualEnd; i++) {
                        pageSet.add(i - 1);
                    }
                }
            } else {
                const num = parseInt(part);
                if (!isNaN(num) && num >= 1 && num <= maxPages) {
                    pageSet.add(num - 1);
                }
            }
            if (pageSet.size > 0) {
                groups.push(Array.from(pageSet).sort((a, b) => a - b));
            }
        });
        return groups;
    }

    // ページ範囲パース (結合用: フラット配列)
    // 戻り値例: [0,1,2,6,7,8] (0-indexed)
    function parsePageRangeFlat(input, maxPages) {
        const groups = parsePageGroups(input, maxPages);
        const allPages = new Set();
        groups.forEach(group => {
            group.forEach(p => allPages.add(p));
        });
        return Array.from(allPages).sort((a, b) => a - b);
    }

    // モードプレビュー更新
    function updateModePreview() {
        const inputVal = manualRangeInput.value.trim();
        if (!inputVal) {
            modePreview.classList.remove('visible');
            return;
        }

        const mode = document.querySelector('input[name="outputMode"]:checked').value;
        let text = '';

        if (mode === 'merge') {
            text = `例: 「${inputVal}」 → すべてのページを含む1つのファイルが生成されます`;
        } else if (mode === 'split') {
            text = `例: 「${inputVal}」 → 指定グループごとのファイルが生成され、ZIPでダウンロード`;
        } else if (mode === 'split-nozip') {
            text = `例: 「${inputVal}」 → 指定グループごとのファイルが0.8秒間隔で個別ダウンロード`;
        }

        modePreview.innerHTML = text;
        modePreview.classList.add('visible');
    }

    // --- イベントリスナー ---

    // ラジオボタンUI制御
    document.querySelectorAll('.radio-card').forEach(card => {
        card.addEventListener('click', function() {
            const radio = this.querySelector('input[type="radio"]');
            radio.checked = true;
            
            // 同グループの選択状態リセット
            const groupName = radio.name;
            document.querySelectorAll(`input[name="${groupName}"]`).forEach(r => {
                r.closest('.radio-card').classList.remove('selected');
            });
            
            // 選択状態適用
            this.classList.add('selected');
            
            if (groupName === 'outputMode') {
                updateModePreview();
            }
        });
    });

    // ファイル読み込み
    pdfInput.addEventListener('change', async function(e) {
        const file = e.target.files[0];
        if (!file) return;

        try {
            // ステータスリセット
            statusArea.className = 'status-area';
            statusArea.innerHTML = '';
            
            const arrayBuffer = await file.arrayBuffer();
            // pdf-libでロードしてページ数確認
            const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
            
            pdfData = arrayBuffer;
            totalPages = pdfDoc.getPageCount();
            fileName = file.name.replace(/\.pdf$/i, '');

            // 情報表示
            fileInfo.textContent = `${file.name} (全${totalPages}ページ)`;
            fileInfo.classList.add('visible');

            // 入力制限更新
            rangeStart.max = totalPages;
            rangeEnd.max = totalPages;

            // ボタン有効化
            executeBtn.disabled = false;

        } catch (error) {
            console.error(error);
            showStatus('PDFの読み込みに失敗しました。暗号化されたPDFの可能性があります。', 'error');
            executeBtn.disabled = true;
        }
    });

    // 範囲追加ボタン
    addRangeBtn.addEventListener('click', () => {
        const sVal = rangeStart.value;
        const eVal = rangeEnd.value;
        let newRange = '';

        if (sVal && eVal) {
            newRange = `${sVal}-${eVal}`;
        } else if (sVal) {
            newRange = sVal;
        } else {
            return;
        }

        let current = manualRangeInput.value.trim();
        if (current) {
            manualRangeInput.value = current + ', ' + newRange;
        } else {
            manualRangeInput.value = newRange;
        }

        rangeStart.value = '';
        rangeEnd.value = '';
        
        // inputイベントを手動発火して全角処理などを走らせる
        manualRangeInput.dispatchEvent(new Event('input'));
    });

    // 手動入力の監視と変換
    manualRangeInput.addEventListener('input', function(e) {
        const original = this.value;
        const converted = toHalfWidth(original);
        if (original !== converted) {
            this.value = converted;
        }
        updateModePreview();
    });

    // --- メイン処理関数群 ---

    // 1. PDF結合 (Merge)
    async function generateMergedPDF(pages) {
        if (pages.length === 0) throw new Error('有効なページが選択されていません。');
        
        const sourcePdf = await PDFLib.PDFDocument.load(pdfData);
        const newPdf = await PDFLib.PDFDocument.create();
        
        // メタデータ
        newPdf.setTitle(fileName + '_split');
        newPdf.setProducer('PDF Split Tool');
        newPdf.setCreator('Local PDF Tool');
        newPdf.setCreationDate(new Date());
        newPdf.setModificationDate(new Date());

        const copiedPages = await newPdf.copyPages(sourcePdf, pages);
        copiedPages.forEach(page => newPdf.addPage(page));

        const pdfBytes = await newPdf.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        saveAs(blob, fileName + '_merged.pdf');
    }

    // 2. PDF分割・ZIP (Split + Zip)
    async function generateSplitPDFs(pageGroups) {
        if (pageGroups.length === 0) throw new Error('有効なページが選択されていません。');

        const zip = new JSZip();
        const sourcePdf = await PDFLib.PDFDocument.load(pdfData);

        for (const group of pageGroups) {
            const newPdf = await PDFLib.PDFDocument.create();
            newPdf.setProducer('PDF Split Tool');
            newPdf.setCreator('Local PDF Tool');
            newPdf.setCreationDate(new Date());
            newPdf.setModificationDate(new Date());

            const copiedPages = await newPdf.copyPages(sourcePdf, group);
            copiedPages.forEach(page => newPdf.addPage(page));

            const pdfBytes = await newPdf.save();
            
            // ファイル名決定 (p1-3.pdf または p5.pdf)
            const startP = group[0] + 1;
            const endP = group[group.length - 1] + 1;
            const subName = (startP === endP) ? `_p${startP}.pdf` : `_p${startP}-${endP}.pdf`;
            
            zip.file(fileName + subName, pdfBytes);
        }

        const zipBlob = await zip.generateAsync({type: 'blob'});
        saveAs(zipBlob, fileName + '_split.zip');
    }

    // 3. PDF分割・ZIPなし (Split + NoZip)
    async function generateSplitPDFsNoZip(pageGroups) {
        if (pageGroups.length === 0) throw new Error('有効なページが選択されていません。');
        
        const sourcePdf = await PDFLib.PDFDocument.load(pdfData);

        for (let i = 0; i < pageGroups.length; i++) {
            const group = pageGroups[i];
            
            showStatus(`PDFファイル生成中... (${i+1}/${pageGroups.length})`, 'processing');

            const newPdf = await PDFLib.PDFDocument.create();
            newPdf.setProducer('PDF Split Tool');
            newPdf.setCreator('Local PDF Tool');
            newPdf.setCreationDate(new Date());
            newPdf.setModificationDate(new Date());

            const copiedPages = await newPdf.copyPages(sourcePdf, group);
            copiedPages.forEach(page => newPdf.addPage(page));

            const pdfBytes = await newPdf.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });

            const startP = group[0] + 1;
            const endP = group[group.length - 1] + 1;
            const subName = (startP === endP) ? `_p${startP}.pdf` : `_p${startP}-${endP}.pdf`;

            saveAs(blob, fileName + subName);

            // ブラウザのブロック回避のため遅延
            if (i < pageGroups.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 800));
            }
        }
    }

    // 画像レンダリング (PDF.js使用)
    async function renderPageToImage(pageNum) {
        // PDF.jsの読み込み (毎回ロードするのは非効率だが安全性を優先)
        // ※メモリ効率を良くするため、本当はloadingTaskを保持すべきだが
        //  コードの単純化とWorker競合回避のため、都度処理とする
        const loadingTask = pdfjsLib.getDocument({data: new Uint8Array(pdfData)});
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(pageNum + 1); // PDF.jsは1-indexed

        const scale = 2.0; // 高画質化
        const viewport = page.getViewport({scale: scale});
        
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        await page.render({canvasContext: context, viewport: viewport}).promise;
        
        return new Promise(resolve => {
            canvas.toBlob(resolve, 'image/jpeg', 0.9);
        });
    }

    // 4. 画像・ZIP保存
    async function generateImagesZIP(pages, mode) {
        if (pages.length === 0) throw new Error('有効なページが選択されていません。');
        
        const zip = new JSZip();
        
        // Mergeモードの場合はフラットにimagesフォルダへ
        // Splitモードの場合はフォルダ分け
        
        if (mode === 'merge') {
            const folder = zip.folder('images');
            for (let i = 0; i < pages.length; i++) {
                showStatus(`画像生成中... (${i+1}/${pages.length})`, 'processing');
                const blob = await renderPageToImage(pages[i]);
                const pNum = String(pages[i] + 1).padStart(3, '0');
                folder.file(`page_${pNum}.jpg`, blob);
            }
        } else {
            // Splitモード: 元のグループ分けを再取得
            const groups = parsePageGroups(manualRangeInput.value, totalPages);
            let totalDone = 0;
            let totalCount = groups.reduce((acc, g) => acc + g.length, 0);

            for (const group of groups) {
                const startP = group[0] + 1;
                const endP = group[group.length - 1] + 1;
                const folderName = `p${startP}-${endP}`;
                const folder = zip.folder(folderName);
                
                for (const pIndex of group) {
                    totalDone++;
                    showStatus(`画像生成中... (${totalDone}/${totalCount})`, 'processing');
                    const blob = await renderPageToImage(pIndex);
                    const pNum = String(pIndex + 1).padStart(3, '0');
                    folder.file(`page_${pNum}.jpg`, blob);
                }
            }
        }

        showStatus('ZIPファイル生成中...', 'processing');
        const zipBlob = await zip.generateAsync({type: 'blob'});
        saveAs(zipBlob, fileName + '_images.zip');
    }

    // 5. 画像・個別保存
    async function generateImagesSingle(pages) {
        if (pages.length === 0) throw new Error('有効なページが選択されていません。');

        for (let i = 0; i < pages.length; i++) {
            showStatus(`画像ダウンロード中... (${i+1}/${pages.length})`, 'processing');
            
            const pIndex = pages[i];
            const blob = await renderPageToImage(pIndex);
            const pNum = String(pIndex + 1).padStart(3, '0');
            
            saveAs(blob, `${fileName}_page_${pNum}.jpg`);

            if (i < pages.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 800));
            }
        }
    }

    // --- 実行ボタン処理 ---
    executeBtn.addEventListener('click', async () => {
        if (!pdfData) {
            showStatus('PDFファイルを選択してください', 'error');
            return;
        }
        if (!manualRangeInput.value.trim()) {
            showStatus('ページ範囲を指定してください', 'error');
            return;
        }

        executeBtn.disabled = true;
        showStatus('処理を開始します...', 'processing');

        const outputMode = document.querySelector('input[name="outputMode"]:checked').value;
        const outputFormat = document.querySelector('input[name="outputFormat"]:checked').value;

        // ページリストの準備
        // Mergeモードや単一画像出力時はフラットな配列が必要
        // Splitモード時はグループ化された配列が必要
        const pagesFlat = parsePageRangeFlat(manualRangeInput.value, totalPages);
        const pageGroups = parsePageGroups(manualRangeInput.value, totalPages);

        try {
            if (outputFormat === 'pdf') {
                if (outputMode === 'merge') {
                    await generateMergedPDF(pagesFlat);
                } else if (outputMode === 'split') {
                    await generateSplitPDFs(pageGroups);
                } else if (outputMode === 'split-nozip') {
                    await generateSplitPDFsNoZip(pageGroups);
                }
            } else if (outputFormat === 'image-zip') {
                await generateImagesZIP(pagesFlat, outputMode);
            } else if (outputFormat === 'image-single') {
                await generateImagesSingle(pagesFlat);
            }

            showStatus('完了しました。<br><small>ダウンロードがブロックされた場合: ファイルを右クリック → プロパティ → ブロックの解除にチェック → OK</small>', 'success');

        } catch (error) {
            console.error('処理エラー:', error);
            showStatus(`エラーが発生しました: ${error.message}`, 'error');
        } finally {
            executeBtn.disabled = false;
        }
    });
</script>

</body>
</html>